// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*!
`usvg` (micro SVG) is an [SVG] parser that tries to solve most of SVG complexity.

SVG is notoriously hard to parse. `usvg` presents a layer between an XML library and
a potential SVG rendering library. It will parse an input SVG into a strongly-typed tree structure
were all the elements, attributes, references and other SVG features are already resolved
and presented in a simplest way possible.
So a caller doesn't have to worry about most of the issues related to SVG parsing
and can focus just on the rendering part.

## Features

- All supported attributes are resolved.
  No need to worry about inheritable, implicit and default attributes
- CSS will be applied
- Only simple paths
  - Basic shapes (like `rect` and `circle`) will be converted into paths
  - Paths contain only absolute *MoveTo*, *LineTo*, *CurveTo* and *ClosePath* segments.
    ArcTo, implicit and relative segments will be converted
- `use` will be resolved and replaced with the reference content
- Nested `svg` will be resolved
- Invalid, malformed elements will be removed
- Relative length units (mm, em, etc.) will be converted into pixels/points
- External images will be loaded
- Internal, base64 images will be decoded
- All references (like `#elem` and `url(#elem)`) will be resolved
- `switch` will be resolved
- Text elements, which are probably the hardest part of SVG, will be completely resolved.
  This includes all the attributes resolving, whitespaces preprocessing (`xml:space`),
  text chunks and spans resolving
- Markers will be converted into regular elements. No need to place them manually
- All filters are supported. Including filter functions, like `filter="contrast(50%)"`
- Recursive elements will be detected an removed

## Limitations

- Unsupported SVG features will be ignored
- CSS support is minimal
- Only [static](http://www.w3.org/TR/SVG11/feature#SVG-static) SVG features,
  e.g. no `a`, `view`, `cursor`, `script`, no events and no animations
- Text elements must be converted into paths before writing to SVG.

[SVG]: https://en.wikipedia.org/wiki/Scalable_Vector_Graphics
*/

#![forbid(unsafe_code)]
#![warn(missing_docs)]
#![warn(missing_copy_implementations)]

mod writer;

use std::collections::HashSet;
pub use usvg_parser::*;
#[cfg(feature = "text")]
pub use usvg_text_layout::*;
pub use usvg_tree::*;

pub use writer::XmlOptions;

/// A struct to keep track of data necessary during writing the SVG file.
pub(crate) struct WriterContext<'a> {
    /// The tree that is to be written.
    pub tree: &'a Tree,
    /// Options for the XML output.
    pub opt: &'a XmlOptions,
    /// A vector of IDs of the corresponding path of textPaths, in tree order.
    pub text_path_map: Vec<String>,
    /// A generator for new IDs.
    pub id_generator: &'a mut IdGenerator,
}

/// A trait to write `usvg::Tree` back to SVG.
pub trait TreeWriting {
    /// Writes `usvg::Tree` back to SVG.
    fn to_string(&self, opt: &XmlOptions) -> String;
}

impl TreeWriting for usvg_tree::Tree {
    fn to_string(&self, opt: &XmlOptions) -> String {
        let used_ids = collect_ids(self);
        let mut id_generator = IdGenerator::new(used_ids);

        let mut writer_context = WriterContext {
            tree: &self,
            opt,
            text_path_map: Vec::new(),
            id_generator: &mut id_generator,
        };

        writer::convert(&mut writer_context)
    }
}

/// A generator for new IDs.
#[derive(Default)]
pub(crate) struct IdGenerator {
    /// A set of IDs that should never be generated by the generator.
    ids: HashSet<String>,
    /// The counter for the current path ID.
    path: u64,
}

impl IdGenerator {
    pub fn new(ids: HashSet<String>) -> Self {
        Self {
            ids,
            ..Self::default()
        }
    }

    pub fn bump_path(&mut self) -> String {
        IdGenerator::bump_impl(&self.ids, &mut self.path, "p")
    }

    fn bump_impl(ids: &HashSet<String>, field: &mut u64, format_str: &str) -> String {
        let mut bump = || {
            *field += 1;
            let result = format!("{}{}", format_str, field);
            result
        };

        let mut id = bump();

        while ids.contains(&id) {
            id = bump();
        }

        id
    }
}

fn collect_ids(tree: &Tree) -> HashSet<String> {
    let mut ids = HashSet::new();
    collect_ids_impl(&tree.root, &mut ids);
    ids.remove("");
    ids
}

fn collect_ids_impl(node: &Node, ids: &mut HashSet<String>) {
    let get_paint_id = |paint: &Paint| match paint {
        Paint::Color(_) => None,
        Paint::LinearGradient(lg) => Some(lg.id.clone()),
        Paint::RadialGradient(rg) => Some(rg.id.clone()),
        Paint::Pattern(pattern) => Some(pattern.id.clone()),
    };

    for node in node.descendants() {
        match *node.borrow() {
            NodeKind::Path(ref path) => {
                ids.insert(path.id.clone());
                if let Some(ref fill) = path.fill {
                    ids.insert(get_paint_id(&fill.paint).unwrap_or_default());
                }
                if let Some(ref stroke) = path.stroke {
                    ids.insert(get_paint_id(&stroke.paint).unwrap_or_default());
                }
            }
            NodeKind::Image(ref image) => {
                ids.insert(image.id.clone());
            }
            NodeKind::Text(ref text) => {
                ids.insert(text.id.clone());
                for chunk in &text.chunks {
                    for span in &chunk.spans {
                        if let Some(ref fill) = span.fill {
                            ids.insert(get_paint_id(&fill.paint).unwrap_or_default());
                        }
                        if let Some(ref stroke) = span.stroke {
                            ids.insert(get_paint_id(&stroke.paint).unwrap_or_default());
                        }
                    }
                }
            }
            NodeKind::Group(ref group) => {
                ids.insert(group.id.clone());

                for filter in &group.filters {
                    ids.insert(filter.id.clone());
                }

                if let Some(mask) = &group.mask {
                    ids.insert(mask.id.clone());

                    if let Some(mask) = &mask.mask {
                        ids.insert(mask.id.clone());
                    }
                }

                if let Some(clip_path) = &group.clip_path {
                    ids.insert(clip_path.id.clone());

                    if let Some(clip_path) = &clip_path.clip_path {
                        ids.insert(clip_path.id.clone());
                    }
                }
            }
        }

        node.subroots(|node| collect_ids_impl(&node, ids));
    }
}
